# 6. 다이나믹 프로그래밍(dp)

- [중복되는 연산을 줄이자 - dp](#중복되는-연산을-줄이자---dp)
- [DP 사용 조건](#dp-사용-조건)
- [탑다운과 보텀업](#탑다운과-보텀업)

## 중복되는 연산을 줄이자 - dp

- 다이나믹 프로그래밍(동적 계획법)
  - 큰 문제를 작게 나누기
    - cf)분할정복: 나눈 문제가 서로 영향x. 퀵정렬 - 한 번 기준 원소pivot가 자리 잡으면 그 위치는 더 안 바뀌고 피벗값 다시 처리하는 부분 문제 없음.
    - dp는 나눈 문제들이 서로 영향 미침. 한 번 해결했던 문제 다시 해결하니까 이미 해결된 부분 문제에 대한 답 저장해놓고, 이미 해결된 애니까 다시 해결할 필요 없다고 답 반환하는 것.
  - 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결
  - 관계식을 정의하는 과정에서의 시간복잡도 & 공간복잡도
    - 공간복잡도: 존재하는 부분 문제의 개수
    - 시간복잡도: 존재하는 부분 문제의 개수 × 한 부분 문제를 풀 때 필요한 반복문의 수행 횟수

## DP 사용 조건

1. 큰 문제를 작은 문제로 나눌 수 있음
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일

## 탑다운과 보텀업

- **탑다운**: 하향식. 큰 문제 해결 위해 작은 문제 호출. 메모이제이션 사용.

  - **메모이제이션**: 캐싱. 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법.
    - 사전(dict) 자료형도 이용 가능: 연속적이지 않은, 일부의 작은 문제에 대한 해답만 필요한 경우에 효과적
  - 피보나치 수열 소스코드(**재귀적**)

    ```python
    # 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
    d = [0] * 100

    # 피보나치 함수(Fibonacci Function)를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)
    def fibo(x):
        # 종료 조건(1 혹은 2일 때 1을 반환)
        if x == 1 or x == 2:
            return 1
        # 이미 계산한 적 있는 문제라면 그대로 반환
        if d[x] != 0:
            return d[x]
        # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
        d[x] = fibo(x - 1) + fibo(x - 2)
        return d[x]

    print(fibo(99))
    ```

  - 재귀 함수 깊이recursion depth 관련 오류 발생 가능
    → sys 라이브러리의 `setrecursionlimit()` 함수 호출로 재귀 제한 완화 가능

- **보텀업**: 상향식. 작은 문제부터 차근차근 답 도출. DP의 전형적 형태😄(권장)

  - 피보나치 수열 소스코드(**반복적**)

    ```python
    # 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
    d = [0] * 100

    # 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
    d[1] = 1
    d[2] = 1
    n = 99

    # 피보나치 함수(Fibonacci Function) 반복문으로 구현(보텀업 다이나믹 프로그래밍)
    for i in range(3, n + 1):
        d[i] = d[i - 1] + d[i - 2]

    print(d[n])
    ```

---

참고

- 이것이 취업을 위한 코딩테스트다 - 다이나믹 프로그래밍
- ICPC 신촌 2022 겨울 알고리즘 캠프 - 동적 계획법(dp)
