# C8. 다이나믹 프로그래밍 - 실전문제 '1로 만들기'

import sys
put = sys.stdin.readline

# 그리디로 elif문 써서 큰 수 순서대로 하면 안 되는 이유
# 맨 처음에 5로 나누는 것보다 1 빼고 시작하는 게 더 작은 케이스가 있을 수 있다!
# 그래서 부분문제로 나누고, 기존 연산값 재활용하는 dp로 해야 함

x = int(put())
d = [0]*30001 # DP 테이블 초기화

# x = 1일 때는 이미 1로 만들어졌으니까 연산 필요 없음 -> 2부터 시작
for i in range(2, x+1):
    # 뒤에 붙은 +1은 계산한 횟수 더하는 것!
    # -1, /2, /3, /5한 케이스 '모두' 계산한 후 그 중 최솟값을 고르고 +1 하면 됨

    # n이 7일 때 n에서 1을 빼는 연산 횟수 1번과, 6을 1로 만드는 d[6] 값을 더하면 d[7] 값 나옴. d[7] = d[6] + 1

    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i-1] + 1

    # min(d[i] + 1, d[i // 5] + 1)가 아닌 이유는 
    # 1 빼는 케이스 하면서 d[i]에 +1 이미 해줘서.
    # min(d[i], d[i // 5] + 1)는
    # min(d[i-1] + 1, d[i // 5] + 1)와 동일. 
    # -1하는 케이스, 나누는 케이스 '모두' 한 후 그 중 최솟값 고르기! 
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1) 
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)    
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)

print(d[x])

