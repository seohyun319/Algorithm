# 3. 그래프와 DFS/BFS

- [그래프](#그래프)
  - [그래프와 트리](#그래프와-트리)
- [그래프의 표현](#그래프의-표현)
  - [인접 행렬](#인접-행렬)
  - [인접 리스트](#인접-리스트)
- [그래프의 탐색](#그래프의-탐색)
  - [DFS](#DFS)
  - [BFS](#BFS)

# 그래프

<aside>
😀 2차원 배열에서의 탐색 문제를 만나면 그래프 형태로 바꿔 생각해보자!

</aside>

<br />

<aside>
😀 “서로 다른 개체(객체)가 연결되어 있다” → 그래프 알고리즘 떠올리기!
ex) 여러 개의 도시가 연결돼있다

</aside>

- 그래프: **노드**(정점vertex)의 집합 V와 **간선**edge의 집합 E로 구성
  - 각 간선은 두 정점의 쌍으로 나타남 (<a,b>) → 정점 간 연결관계 나타냄
- 그래프에서 쓰이는 용어
  - **무방향 그래프** : 간선의 방향이 없음.
    즉 a와 b 사이에 간선이 있으면 a->b, b->a 둘 다 가능
  - **방향 그래프** : 간선의 방향이 있음
    화살표 방향에 따라 갈 수도 있고 안 갈 수도 있음
  - **인접** : 정점 A와 정점 B가 간선 하나로 연결되어 있음. 두 정점이 양끝인 간선이 있는 것
    두 노드(도시)가 간선(도로)으로 연결됨 → ‘두 노드는 인접하다’
  - **사이클** : 한 정점에서 시작해서 다시 그 정점으로 돌아오는 경로. A->B->C->A 같은 것
  - **가중치 그래프** : 간선들에 가중치가 부여된 그래프
  - **연결 그래프** : 정점들이 모두 이어져 있는 그래프

## 그래프와 트리

|                     | 그래프                         | 트리             |
| ------------------- | ------------------------------ | ---------------- |
| 방향성              | 방향 그래프 혹은 무방향 그래프 | 방향 그래프      |
| 순환성              | 순환 및 비순환                 | 비순환           |
| 루트 노드 존재 여부 | 루트 노드가 없음               | 루트 노드가 존재 |
| 노드간 관계성       | 부모와 자식 관계 없음          | 부모와 자식 관계 |
| 모델의 종류         | 네트워크 모델                  | 계층 모델        |

# 그래프의 표현

## 인접 행렬

- **인접 행렬**: 2차원 배열로 그래프 연결 관계 표현

  - 2차원 배열에 각 노드가 연결된 형태 기록
  - 모든 관계 저장 → $`O(V^2)`$
    - 특정 노드와 연결된 인접 노드 순회해야 하는 경우 메모리 공간 낭비 적음
      - 특정 노드 A에서 다른 특정 노드 B로 이어진 간선의 비용 $`O(1)`$ 시간으로 즉시 알 수 있음
    - 노드 개수 많을수록 관계 저장에 메모리 낭비
  - 연결 안 된 노드끼리는 무한INF으로 초기화

    ```python
    INF = 999999999 # 무한의 비용 선언

    # 2차원 리스트를 이용해 인접 행렬 표현
    graph = [
        [0, 7, 5],
        [7, 0, INF],
        [5, INF, 0]
    ]

    print(graph)
    ```

## 인접 리스트😊

- **인접 리스트**: 리스트로 그래프 연결 관계 표현

  - 모든 노드에 연결된 노드에 대한 정보 차례로 연결해 저장
  - 연결된 정보만 저장 → $`O(E)`$ 간선 개수만큼
    - 메모리 효율적 사용
    - 특정한 두 노드가 연결돼있는지 정보 얻는 속도 느림. 연결된 데이터 하나씩 확인해야해서. $`O(V)`$
  - `append()` 사용

    ```python
    # 행(Row)이 3개인 2차원 리스트로 인접 리스트 표현
    graph = [[] for _ in range(3)]

    # 노드 0에 연결된 노드 정보 저장 (노드, 거리)
    graph[0].append((1, 7))
    graph[0].append((2, 5))

    # 노드 1에 연결된 노드 정보 저장 (노드, 거리)
    graph[1].append((0, 7))

    # 노드 2에 연결된 노드 정보 저장 (노드, 거리)
    graph[2].append((0, 5))

    print(graph)
    ```

|                | 인접 행렬                             | 인접 리스트                                   |
| -------------- | ------------------------------------- | --------------------------------------------- |
| 사용하는 것    | 2차원 배열                            | 리스트                                        |
| 간선 정보 저장 | 모든 관계 저장→ ⁍                     | 연결된 정보만 저장 → ⁍                        |
| 간선의 비용    | ⁍. 인접 노드 순회 시 메모리 낭비 적음 | ⁍. 특정 두 노드 연결 여부 아는 게 상대적 느림 |
| 알고리즘       | 플로이드 워셜 알고리즘                | 다익스트라 최단 경로 알고리즘                 |

# 그래프의 탐색

그래프 탐색: 하나의 노드를 시작으로 다수의 노드 방문

## DFS

- 깊이Depth 우선First 탐색Search. 깊은 부분 우선 탐색
- 스택 사용 (→ 재귀 사용하면 간결 구현 가능)
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
  2. 스택의 최상단 노드에 방문하지 않은 인접 노드가
     1. 있으면 그 인접 노드를 스택에 넣고 방문 처리.
     2. 없으면 스택에서 최상단 노드 꺼냄
  3. 2번 과정을 더이상 할 수 없을 때까지 반복
- 데이터 개수가 N개면 O(N)
- DFS 예제

  ```python
  # silver3-2606. 바이러스
  import sys
  put = sys.stdin.readline

  n = int(put())
  m = int(put())
  graph = [[] for _ in range(n+1)]
  visited = [0] * (n+1)

  for _ in range(m):
      x, y = map(int, put().split())
      graph[x].append(y)
      graph[y].append(x)

  def dfs(v):
      visited[v] = 1 # 현재 노드 방문 처리
      # 현재 노드와 관련된 노드 재귀적으로 방문
      for i in graph[v]:
          if not visited[i]:
              dfs(i)

  dfs(1)

  print(sum(visited) - 1)	# 1번 컴퓨터는 이미 방문한 거니까 빼줌
  ```

  ```python
  # DFS 함수 정의
  def dfs(graph, v, visited):
      # 현재 노드를 방문 처리
      visited[v] = True
      print(v, end=' ')
      # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
      for i in graph[v]:
          if not visited[i]:
              dfs(graph, i, visited)

  # 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
  graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
  ]

  # 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
  visited = [False] * 9 # False로 초기화

  # 정의된 DFS 함수 호출
  dfs(graph, 1, visited)
  ```

## BFS

- 너비Breadth 우선 탐색. 가까운 노드 우선 탐색.
- 큐 사용
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
  2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리 (→ 먼저 들어온 것이 먼저 나가 가까운 노드부터 탐색)
  3. 2번 과정을 더이상 할 수 없을 때까지 반복
- O(N). 일반적으로 DFS보다 수행시간이 좋음
- BFS 예제

  ```python
  # gold4-14940. 쉬운 최단거리

  import sys
  put = sys.stdin.readline
  from collections import deque

  # 가로와 세로로만 움직일 수 있을 때 모든 지점에 대해서 목표지점까지의 거리
  # 0은 갈 수 없는 땅, 1은 갈 수 있는 땅, 2는 목표지점

  n, m = map(int, put().split())
  map = [list(map(int, put().split())) for _ in range(n)] # 지도
  dx = [0, 1, 0, -1]
  dy = [-1, 0, 1, 0]
  que = deque()

  def bfs():
      while que:
          x, y = que.popleft()
          for i in range(4):
              nx, ny = x + dx[i], y + dy[i]
              if 0 <= nx < n and 0 <= ny < m and map[nx][ny] == 1: # 갈 수 있는 곳
                  que.append([nx, ny])
                  map[nx][ny] = map[x][y]+1

  for i in range(n):
      for j in range(m):
          if map[i][j] == 2: # 목표 지점
              que.append([i, j])
              map[i][j] = 2
              break

  bfs()

  for i in range(n):
      for j in range(m):
          d = map[i][j]
          if d == 0: print(0, end=' ')
          else: print(d-2, end=' ')
      print()
  ```

  ```python
  from collections import deque

  # BFS 함수 정의
  def bfs(graph, start, visited):
      # 큐(Queue) 구현을 위해 deque 라이브러리 사용
      queue = deque([start])
      # 현재 노드를 방문 처리
      visited[start] = True
      # 큐가 빌 때까지 반복
      while queue:
          # 큐에서 하나의 원소를 뽑아 출력
          v = queue.popleft()
          print(v, end=' ')
          # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
          for i in graph[v]:
              if not visited[i]:
                  queue.append(i)
                  visited[i] = True

  # 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
  graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
  ]

  # 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
  visited = [False] * 9

  # 정의된 BFS 함수 호출
  bfs(graph, 1, visited)
  ```

|           | DFS                      | BFS                      |
| --------- | ------------------------ | ------------------------ |
| 동작 원리 | 스택                     | 큐                       |
| 구현 방법 | 재귀 함수 이용           | 큐 자료구조 이용         |
| 구현 문제 | 사이클 검출, 재귀적 구조 | 최단거리, 최소 연산 횟수 |

---

참고

- 이것이 취업을 위한 코딩테스트다 - DFS, BFS
- ICPC 신촌 2022 겨울 알고리즘 캠프 - 그래프 / 그래프 탐색
