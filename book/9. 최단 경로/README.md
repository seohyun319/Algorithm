# 7. 최단 경로

- [가장 빠르게 도달하는 방법](#가장-빠르게-도달하는-방법)
- [다익스트라 최단 경로 알고리즘](#다익스트라-최단-경로-알고리즘)
- [벨만포드 알고리즘](#벨만포드-알고리즘)
- [플로이드 워셜 알고리즘](#플로이드-워셜-알고리즘)

## 가장 빠르게 도달하는 방법

- **최단 경로**: 가장 짧은 경로 찾는 알고리즘. 길찾기 문제.
- 보통 그래프로 표현. 노드(지점), 간선(지점간 연결된 도로)
- 그리디, dp의 한 유형
- 간선에 가중치가 있는 가중치 그래프에서는 BFS 사용 불가

|                    | 인접 행렬                             | 인접 리스트                                   |
| ------------------ | ------------------------------------- | --------------------------------------------- |
| 사용하는 것        | 2차원 배열                            | 리스트                                        |
| 간선 정보 저장     | 모든 관계 저장→ ⁍                     | 연결된 정보만 저장 → ⁍                        |
| 간선의 비용        | ⁍. 인접 노드 순회 시 메모리 낭비 적음 | ⁍. 특정 두 노드 연결 여부 아는 게 상대적 느림 |
| 알고리즘           | 플로이드 워셜 알고리즘                | 다익스트라 최단 경로 알고리즘                 |
| 벨만 포드 알고리즘 |
| 가중치 저장        | graph[a][b] = c                       | graph[a].append((b, c))                       |

|                  | 다익스트라                                                     | 벨만 포드                                                              | 플로이드 워셜                                                                      |
| ---------------- | -------------------------------------------------------------- | ---------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| 노드 간 관계     | 1 : 多. 특정 노드에서 출발해 다른 노드로 가는 각각의 최단 경로 | 1 : 多. 하나의 노드에서 ‘모든’ 노드로 가는 최단 거리 구함              | 多 : 多. 모든 노드에서 다른 모든 노드까지의 최단 경로                              |
| 반복             | 방문 안 한 노드 중 최단거리가 가장 짧은 정점 방문 (그리디)     | 각 간선을 거쳐 다른 노드로 가는 비용 계산해 갱신 (매번 모든 간선 확인) | ‘바로 이동하는 거리’와 ‘특정한 노드를 거쳐 이동하는 거리’ 중 짧은 것으로 갱신 (DP) |
| 음수 가중치 간선 | X                                                              | O (음수 순환(사이클) X)                                                | O (음수 순환(사이클) X)                                                            |
| 시간 복잡도      | ⁍                                                              | ⁍                                                                      | ⁍                                                                                  |
| 그래프           | 인접 리스트 (힙 사용)                                          | 인접 리스트                                                            | 인접 행렬                                                                          |
| 사용 환경        | 기본                                                           | 음수 존재 시                                                           | 모든 시작점에 대해                                                                 |

## 다익스트라 최단 경로 알고리즘

- 다익스트라Dijkstra 최단 경로 알고리즘: 그래프에서 여러 개의 노드가 있을 때, 특정 노드에서 출발해 다른 노드로 가는 각각의 최단 경로 구하는 알고리즘
- ‘음의 간선’이 없을 때 정상 동작
- 그리디 알고리즘. (매번 ‘가장 비용이 적은 노드’ 선택해 임의 과정 반복)
- 인접 리스트 이용. (각 노드와 연결된 모든 간선 정보 리스트에 저장)
- 원리
  1. 출발 노드 설정
  2. 최단 거리 테이블 초기화
     1. 자기 자신에서 자기 자신으로 가는 비용 = 0
     2. 연결되지 X = 무한(int(1e9): 10억)
  3. 방문하지 않은 노드 중 최단거리가 짧은 노드 선택
  4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산해 최단 거리 테이블 갱신
     - ‘각 노드에 대한 현재까지의 최단 거리’ 정보를 항상 1차원 리스트(최단 거리 테이블)에 저장해 리스트 계속 갱신.
     - 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾음.
     - 한 번 선택된 노드는 최단 거리가 감소하지 않음. 최단 거리가 완전히 선택됐기 때문.
     - 그래서 마지막 노드에 대해서는 해당 노드를 거쳐 다른 노드로 가는 경우 확인할 필요 없음.
  5. 3, 4 과정 반복
- 매번 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택
- 방법 1. 간단한 다익스트라 알고리즘

  - $**`O(V^2)`**$. V는 노드 개수, O(V)번에 걸쳐 최단 거리가 가장 짧은 노드 매번 선형 탐색해야 + 현재 노드와 연결된 노드를 매번 일일이 확인
  - 단계마다 ‘방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택’하기 위해 매 단계마다 1차원 리스트의 모든 원소를 확인(순차탐색)
  - 모든 리스트는 (노드의 개수 + 1) 크기로 할당해, 노드 번호를 인덱스로 해 바로 리스트에 접근할 수 있도록 함
  - ~~간단한 다익스트라 알고리즘~~

    ```python
    import sys
    input = sys.stdin.readline
    INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

    # 노드의 개수, 간선의 개수를 입력받기
    n, m = map(int, input().split())
    # 시작 노드 번호를 입력받기
    start = int(input())
    # 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
    graph = [[] for i in range(n + 1)]
    # 방문한 적이 있는지 체크하는 목적의 리스트를 만들기
    visited = [False] * (n + 1)
    # 최단 거리 테이블을 모두 무한으로 초기화
    distance = [INF] * (n + 1)

    # 모든 간선 정보를 입력받기
    for _ in range(m):
        a, b, c = map(int, input().split())
        # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
        graph[a].append((b, c))

    # 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
    def get_smallest_node():
        min_value = INF
        index = 0 # 가장 최단 거리가 짧은 노드(인덱스)
        for i in range(1, n + 1):
            if distance[i] < min_value and not visited[i]:
                min_value = distance[i]
                index = i
        return index

    def dijkstra(start):
        # 시작 노드에 대해서 초기화
        distance[start] = 0
        visited[start] = True
        for j in graph[start]:
            distance[j[0]] = j[1]
        # 시작 노드를 제외한 전체 n - 1개의 노드에 대해 반복
        for i in range(n - 1):
            # 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
            now = get_smallest_node()
            visited[now] = True
            # 현재 노드와 연결된 다른 노드를 확인
            for j in graph[now]:
                cost = distance[now] + j[1]
                # 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
                if cost < distance[j[0]]:
                    distance[j[0]] = cost

    # 다익스트라 알고리즘을 수행
    dijkstra(start)

    # 모든 노드로 가기 위한 최단 거리를 출력
    for i in range(1, n + 1):
        # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
        if distance[i] == INF:
            print("INFINITY")
        # 도달할 수 있는 경우 거리를 출력
        else:
            print(distance[i])
    ```

- 방법 2. 개선된 다익스트라 알고리즘

  - $`O(ElogV)`$. E는 간선 개수.
    - 모든 간선 검사 시간은 총 최대 간선의 개수 $O(E)$
    - 우선순위 큐에 원소를 추가/삭제 (현재 우선순위큐에서 꺼낸 노드와 연결된 다른 노드 중 방문하지 않았는데 최단거리 짧은 노드 선택) $O(logE)$ (힙(우선순위 큐) 특성 상)
    - 중복 간선 포함하지 않는 경우, E는 항상 V$^2$보다 작음. $logE$는 $logV^2$보다 작음.
      O($logV^2$) = O($2logV$) = O($logV$).
    - ⇒ 전체 시간 복잡도는 O($ElogV$)
  - 힙 자료구조 사용, 특정 노드까지의 최단 거리에 대한 정보를 힙에 담아서 처리
    → 출발 노드로부터 가장 거리가 짧은 노드를 더 빠르게 찾을 수 있음. 여기서 로그시간.
  - 우선순위 큐 이용해 시작 노드로부터 ‘거리’가 짧은 노드 순서대로 큐에서 나올 수 있도록 함
  - 개선된 다익스트라 알고리즘

    ```python
    import heapq
    import sys
    input = sys.stdin.readline
    INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

    # 노드의 개수, 간선의 개수를 입력받기
    n, m = map(int, input().split())
    # 시작 노드 번호를 입력받기
    start = int(input())
    # 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
    graph = [[] for i in range(n + 1)]
    # 최단 거리 테이블을 모두 무한으로 초기화
    distance = [INF] * (n + 1)

    # 모든 간선 정보를 입력받기
    for _ in range(m):
        a, b, c = map(int, input().split())
        # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
        graph[a].append((b, c))

    def dijkstra(start):
        q = []
        # 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
        heapq.heappush(q, (0, start))
        distance[start] = 0
        while q: # 큐가 비어있지 않다면
            # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
            dist, now = heapq.heappop(q)
            # 현재 노드가 이미 처리된 적이 있는 노드라면 무시
            if distance[now] < dist:
                continue
            # 현재 노드와 연결된 다른 인접한 노드들을 확인
            for i in graph[now]:
                cost = dist + i[1]
                # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
                if cost < distance[i[0]]:
                    distance[i[0]] = cost
                    heapq.heappush(q, (cost, i[0]))

    # 다익스트라 알고리즘을 수행
    dijkstra(start)

    # 모든 노드로 가기 위한 최단 거리를 출력
    for i in range(1, n + 1):
        # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
        if distance[i] == INF:
            print("INFINITY")
        # 도달할 수 있는 경우 거리를 출력
        else:
            print(distance[i])
    ```

## 벨만포드 알고리즘

- 벨만포드 알고리즘: 하나의 정점에서 모든 정점으로 가는 최단거리를 구함
- 시작점부터 모든 점까지의 최단거리를 무한대로 초기화하고 이 값을 최단거리에 가깝게 갱신해나감
- 음의 간선 (순환 x)이 있는 경우에도 사용 가능.
  - 가중치 합이 음수인 사이클 있으면 경로 가중치 합이 무한히 작아질 수 있기에 최단 경로 존재 불가
- 시간복잡도 $`O(VE)`$ 다익스트라보다 느림
- 원리
  1. 출발 노드 설정
  2. 최단 거리 테이블 초기화
  3. 전체 간선 E개를 하나씩 확인
  4. 각 간선을 거쳐 다른 노드로 가는 비용을 계산해 최단 거리 테이블 갱신
  5. 3, 4번 과정을 N-1번 반복
     1. 음수 간선 순환 발생 여부 체크하려면 이 과정 한 번 더 하면 됨. (N번째)
     2. 이때 최단 거리 테이블 갱신되면 음수 간선 순환이 존재하는 것.
        1. 경로에 N(혹은 V)번째 간선이 추가되는 순간 사이클 진입한 것
- 매번 모든 간선 전부 확인
  - 다익스트라 알고리즘에서의 최적의 해 항상 포함
- 벨만포드 알고리즘

  ```python
  import sys
  import collections
  input = sys.stdin.readline
  INF = int(1e9)

  n, m = map(int, input().split()) # 노드의 개수, 간선의 개수를 입력받기
  edges = [] # 모든 간선에 대한 정보를 담는 리스트 생성
  dist = [INF] * (n+1) # 최단 거리 테이블을 모두 무한으로 초기화

  # 모든 간선 정보를 입력받기
  for _ in range(m):
      a, b, c = map(int, input().split())
  		# a번 노드에서 b번 노드로 가는 비용(가중치)이 c
      edges.append((a, b, c))

  # 벨만 포드 알고리즘
  def bellmanford(start):
      dist[start] = 0 # 시작 노드에 대해서 초기화
      for i in range(n): # 정점 수만큼 반복
          for j in range(m): # 매 반복 마다 모든 간선 확인
              node = edges[j][0] # 현재 노드 받아오기
              next_node = edges[j][1] # 다음 노드 받아오기
              cost = edges[j][2] # 가중치 받아오기
              # 현재 간선을 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
              if dist[node] != INF and dist[next_node] > dist[node] + cost:
                  dist[next_node] = dist[node] + cost
                  # n번째 라운드에서도 값이 갱신된다면 음수 순환이 존재
                  if i == n-1:
                      return True
      return False

  # 벨만 포드 알고리즘 수행
  negative_cycle = bf(1) # 1번 노드가 시작 노드

  if negative_cycle:
      print('-1')
  else:
      # 1번 노드를 제외한 다른 모든 노드로 가기 위한 최단 거리 출력
      for i in range(2, n+1):
  				# 도달할 수 없는 경우 -1 출력
          if dist[i] == INF:
              print('-1')
  				# 도달할 수 있는 겨우 거리를 출력
          else:
              print(dist[i])
  ```

## 플로이드 워셜 알고리즘

- 플로이드 워셜 알고리즘: 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우 사용
  - cf) 다익스트라: 한 지점에서 다른 특정 지점까지의 최단 경로 구해야 하는 경우
  - 단계마다 ‘거쳐 가는 노드’를 기준으로 알고리즘을 수행. 근데 매번 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾을 필요가 없음.
- 다이나믹 프로그래밍. N(노드 개수)번 만큼의 단계를 반복하며 ‘점화식에 맞게’ 2차원 리스트 갱신.
- 인접 행렬 이용. 모든 노드에 대해 다른 노드로 가는 최소 비용을 2차원 리스트에 저장.
- 원리
  1. 초기 테이블 설정
     1. 자기 자신에서 자기 자신으로 가는 비용 = 0
     2. 연결되지 X = 무한(int(1e9): 10억)
  2. 2차원 리스트에 최단 거리 정보 저장하는 $O(N^2)$의 연산
     - 현재 노드를 거쳐가는 경우 고려
     - 현재 확인하고 있는 노드를 제외한, N-1개의 노드 중에서 서로 다른 노드 (A, B)쌍 선택 → $_{N-1}P_2$개의 $D_{ab}$가 나옴
     - $D_{ab} = min(D_{ab}, D_{ak} + D_{kb})$
       - ’A에서 B로 가는 최소 비용’과 ‘A에서 K를 거쳐 B로 가는 비용을 비교하여 더 작은 값으로 갱신하겠다
       - ‘바로 이동하는 거리’가 ‘특정한 노드를 거쳐 이동하는 거리’보다 더 많은 비용을 가진다면 이를 더 짧은 것으로 갱신
       - $_{N-1}P_2$개의 쌍을 반복해서 확인하면 됨. O($_{N-1}P_2$)는 O(N$^2$)
  3. 2번 과정을 N(노드 개수)번만큼 수행
- $**`O(N^3)`**$. 알고리즘상으로 N(노드 개수)번의 단계 수행, 단계마다 2차원 리스트에 최단 거리 정보 저장하는 O(N$^2$)의 연산을 통해 ‘현재 노드를 거쳐 가는’ 모든 경로를 고려.
- 플로이드 워셜 알고리즘 소스 코드

  ```python
  INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

  # 노드의 개수 및 간선의 개수를 입력받기
  n = int(input())
  m = int(input())
  # 2차원 리스트(그래프 표현)를 만들고, 모든 값을 무한으로 초기화
  graph = [[INF] * (n + 1) for _ in range(n + 1)]

  # 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
  for a in range(1, n + 1):
      for b in range(1, n + 1):
          if a == b:
              graph[a][b] = 0

  # 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화
  for _ in range(m):
      # A에서 B로 가는 비용은 C라고 설정
      a, b, c = map(int, input().split())
      graph[a][b] = c

  # 점화식에 따라 플로이드 워셜 알고리즘을 수행
  for k in range(1, n + 1):
      for a in range(1, n + 1):
          for b in range(1, n + 1):
              graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

  # 수행된 결과를 출력
  for a in range(1, n + 1):
      for b in range(1, n + 1):
          # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
          if graph[a][b] == 1e9:
              print("INFINITY", end=" ")
          # 도달할 수 있는 경우 거리를 출력
          else:
              print(graph[a][b], end=" ")
      print()
  ```

<aside>
😀 최단 경로 찾아야 하는 문제
노드와 간선의 개수가 모두 많음 - 다익스트라 알고리즘
노드의 개수가 적음 - 플로이드 워셜 알고리즘

</aside>

---

참고

- 이것이 취업을 위한 코딩테스트다 - 최단 경로
- ICPC 신촌 2022 겨울 알고리즘 캠프 - 최단 경로
